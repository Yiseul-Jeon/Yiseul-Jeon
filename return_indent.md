# 📘 팩토리얼(Factorial) 함수 완전정복 (책 293쪽 기준)

## ✅ 팩토리얼이란?

> 팩토리얼(Factorial) 은 어떤 자연수 n에 대해, 1부터 n까지의 모든 수를 곱한 값을 말해요.
> 

📌 기호로는 `n!`이라고 쓰고, 다음과 같이 정의해요:

- `1! = 1`
- `2! = 2 × 1 = 2`
- `3! = 3 × 2 × 1 = 6`
- `4! = 4 × 3 × 2 × 1 = 24`
- `5! = 5 × 4 × 3 × 2 × 1 = 120`

👉 즉, **`n! = n × (n-1) × (n-2) × ... × 1`** 이 되는 거죠!

---

## ✅ 반복문으로 팩토리얼 함수 만들기

```python
# 반복문으로 팩토리얼 구하기

def factorial(n):
    output = 1
    for i in range(1, n + 1):
        output *= i
    return output

# 함수 테스트 출력
print("1!:", factorial(1))
print("2!:", factorial(2))
print("3!:", factorial(3))
print("4!:", factorial(4))
print("5!:", factorial(5))

```

---

## 🔁 재귀호출로 팩토리얼 함수 만들기

```python
# 재귀함수로 팩토리얼 구하기

def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

# 함수 테스트 출력
print("1!:", factorial(1))
print("2!:", factorial(2))
print("3!:", factorial(3))
print("4!:", factorial(4))
print("5!:", factorial(5))

```

### 🔍 재귀함수란?

> 재귀함수(Recursive Function) 는 자기 자신을 다시 호출하는 함수를 말해요.
> 

📌 팩토리얼 정의 그대로 코드를 구성해요:

- `n! = n × (n-1)!`
- `1! = 1` (종료 조건)

예: `factorial(3)` 호출 순서

- `3 × factorial(2)`
- → `2 × factorial(1)`
- → `1` (종료)
- → 계산: `2 × 1 = 2`, `3 × 2 = 6`

➡️ 결과는 `6`!

---

## 📊 일반함수(반복문) vs 재귀함수 비교

| 항목 | 일반 함수 (반복문) | 재귀 함수 |
| --- | --- | --- |
| 기본 방식 | `for`나 `while` 반복문 사용 | 함수 자신을 다시 호출함 |
| 코드 가독성 | 길어질 수 있음 | 수학적 정의와 유사해서 간결함 |
| 처리 속도 | 일반적으로 더 빠름 | 함수 호출 비용으로 느릴 수 있음 |
| 메모리 사용 | 적음 (변수만 사용) | 많음 (호출마다 스택에 저장) |
| 무한 반복 위험 | 논리적 오류로 생김 | 종료 조건 미정의 시 무한 루프 위험 |
| 디버깅 | 상대적으로 쉬움 | 호출 깊이 따라 어려움 있음 |
| 대표 예 | 누적합, 평균, 검색 등 | 팩토리얼, 피보나치, 트리 탐색 등 |

함수 방식 선택할 때,

- “속도가 중요할 땐 반복문!”
- “코드를 수학처럼 간결하게 표현하고 싶을 땐 재귀!”

---

| 항목 | 일반 함수 (반복문) | 재귀 함수 |
| --- | --- | --- |
| 기본 방식 | `for`나 `while` 반복문 사용 | 함수 자신을 다시 호출함 |
| 코드 가독성 | 길어질 수 있음 | 수학적 정의와 유사해서 간결함 |
| 처리 속도 | 일반적으로 더 빠름 | 함수 호출 비용으로 느릴 수 있음 |
| 메모리 사용 | 적음 (변수만 사용) | 많음 (호출마다 스택에 저장) |
| 무한 반복 위험 | 논리적 오류로 생김 | 종료 조건 미정의 시 무한 루프 위험 |
| 디버깅 | 상대적으로 쉬움 | 호출 깊이 따라 어려움 있음 |
| 대표 예 | 누적합, 평균, 검색 등 | 팩토리얼, 피보나치, 트리 탐색 등 |

---

## 🔍 이 함수는 어떻게 동작하나요? (반복문 버전 기준)

1. `factorial(n)` 함수는 입력된 숫자 `n`에 대해
2. `1부터 n까지 반복문을 돌면서`
3. `output`이라는 변수에 곱셈을 누적합니다
4. 반복이 끝나면 최종 결과인 팩토리얼 값을 `return`으로 돌려줍니다.

예: `factorial(4)`

- output = 1 → 1×1 = 1
- i=2 → 1×2 = 2
- i=3 → 2×3 = 6
- i=4 → 6×4 = 24

→ 결과는 `24`!

---

## 📊 팩토리얼 vs 피보나치 수열 비교

| 항목 | 팩토리얼 | 피보나치 수열 |
| --- | --- | --- |
| 정의 | 1부터 n까지 곱한 값 | 앞의 두 항을 더해 다음 항 생성 |
| 수식 | `n! = n × (n-1) × ... × 1` | `F(n) = F(n-1) + F(n-2)` |
| 예시 | `5! = 120` | `F(5) = 3 + 2 = 5` |
| 시작값 | `1! = 1` | `F(0) = 0, F(1) = 1` |
| 계산방식 | 반복 또는 재귀 | 반복 또는 재귀 |
| 증가속도 | 매우 빠르게 커짐 (n!) | 느리게 커짐 (지수적이나 덜 큼) |
| 활용 예 | 순열, 조합 계산 등 | 알고리즘, 재귀, 동적계획 등 |

---

## 💡 마무리 요약

- 팩토리얼은 **곱셈을 누적**하는 반복 구조
- 반복문 버전과 재귀 버전 모두 가능
- `+=` 대신 `=` 연산자를 사용해야 해요
- 피보나치 수열은 **덧셈을 누적**하는 구조로 팩토리얼과 비교되며, 알고리즘 실습에서 자주 나와요!
- 일반 함수와 재귀 함수는 상황에 따라 선택해서 사용하는 것이 중요해요!

---

🧠 **슬이 팁:**

> 팩토리얼은 "곱셈 반복", 피보나치는 "덧셈 반복"!
> 
> 
> 재귀 함수는 마치 러시아 인형처럼, 계속 자신을 부르다 마지막에 정답 하나 꺼내오는 구조야 😊
>